<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lekcja 26: Input Validation - Hack & Learn</title>
    
    <link rel="stylesheet" href="style.css">

    <style>
        /* Akcent: Validation Green (Clean Code / Approved) */
        :root {
            --accent: #00e676;
            --accent-glow: rgba(0, 230, 118, 0.3);
            --bad: #ff1744;
        }
        
        .valid { color: #00e676; font-weight: bold; }
        .invalid { color: #ff1744; font-weight: bold; text-decoration: line-through; }
        .code-box { font-family: monospace; background: #111; padding: 10px; border: 1px solid #333; margin: 10px 0; }
    </style>
</head>
<body>

<div class="container">
    <header>
        <h1>INPUT VALIDATION & SANITIZATION</h1>
        <p>MODU≈Å 26: Allowlist vs Blocklist, Encoding i pu≈Çapki Regexa</p>
    </header>

    <!-- 1. TRIADA OBRONY -->
    <section>
        <h2>> TRIADA OBRONY DANYCH</h2>
        <p>Programi≈õci mylƒÖ te pojƒôcia. Jako pentester/audytor musisz je rozr√≥≈ºniaƒá, by dawaƒá dobre rekomendacje.</p>
        
        <div class="card">
            <ul>
                <li><strong>Walidacja (Validation):</strong> Sprawdzenie, czy dane sƒÖ poprawne. Odpowied≈∫: TAK/NIE. <br><em>Np. "Czy to jest email?"</em></li>
                <li><strong>Sanityzacja (Sanitization):</strong> Usuniƒôcie niebezpiecznych znak√≥w. Odpowied≈∫: Wyczyszczony ciƒÖg. <br><em>Np. Usuniƒôcie `&lt;script&gt;` z komentarza.</em></li>
                <li><strong>Kodowanie (Encoding):</strong> Zamiana znak√≥w specjalnych na bezpieczny format wy≈õwietlania. <br><em>Np. Zamiana `&lt;` na `&amp;lt;`.</em></li>
            </ul>
        </div>
    </section>

    <!-- 2. ALLOWLIST vs BLOCKLIST -->
    <section>
        <h2>> ALLOWLIST (BIA≈ÅA LISTA) TO KR√ìL</h2>
        <p>Najwiƒôkszy b≈ÇƒÖd w kodzie? Pr√≥ba przewidzenia "z≈Çych znak√≥w" (Blocklist).</p>

        <div class="card">
            <h3>‚ùå PODEJ≈öCIE "BLOCKLIST" (Z≈Çe)</h3>
            <p>Programista my≈õli: <em>"Zablokujƒô s≈Çowo `script`, ≈ºeby nie by≈Ço XSS"</em>.</p>
            <div class="code-box">
                input.replace("script", "");
            </div>
            <p><strong>Bypass hakera:</strong></p>
            <ul>
                <li><code>&lt;scr<span class="invalid">script</span>ipt&gt;</code> -> Po usuniƒôciu ≈õrodka zostaje <code>&lt;script&gt;</code>.</li>
                <li><code>&lt;img onerror=...&gt;</code> (Nie u≈ºywa s≈Çowa script).</li>
                <li><code>&lt;SCRIPT&gt;</code> (Du≈ºe litery).</li>
            </ul>
        </div>

        <div class="card" style="border-color: var(--accent);">
            <h3>‚úÖ PODEJ≈öCIE "ALLOWLIST" (Dobre)</h3>
            <p>Programista my≈õli: <em>"Akceptujƒô TYLKO litery i cyfry"</em>.</p>
            <div class="code-box">
                if (!input.matches("^[a-zA-Z0-9]*$")) { return ERROR; }
            </div>
            <p>To podej≈õcie jest bezpieczne, bo odrzuca wszystko, czego nie znamy (w tym znaki ataku <code>&lt;</code>, <code>'</code>, <code>/</code>).</p>
        </div>
    </section>

    <!-- 3. OUTPUT ENCODING -->
    <section>
        <h2>> CONTEXT-AWARE ENCODING</h2>
        <p>To, jak kodujesz dane, zale≈ºy od tego, gdzie je wy≈õwietlasz. To jedyny spos√≥b na powstrzymanie XSS.</p>

        <div class="card">
            <table>
                <tr>
                    <th>Kontekst</th>
                    <th>Przyk≈Çad</th>
                    <th>Bezpieczne kodowanie</th>
                </tr>
                <tr>
                    <td><strong>HTML Body</strong></td>
                    <td><code>&lt;div&gt;USER_INPUT&lt;/div&gt;</code></td>
                    <td>HTML Entity Encoding (<code>&lt;</code> &rarr; <code>&amp;lt;</code>)</td>
                </tr>
                <tr>
                    <td><strong>Atrybut HTML</strong></td>
                    <td><code>&lt;input value="USER_INPUT"&gt;</code></td>
                    <td>Attribute Encoding (<code>"</code> &rarr; <code>&amp;quot;</code>)</td>
                </tr>
                <tr>
                    <td><strong>JavaScript</strong></td>
                    <td><code>var x = "USER_INPUT";</code></td>
                    <td>Unicode Escaping (<code>'</code> &rarr; <code>\u0027</code>)</td>
                </tr>
            </table>
            <p class="highlight">U≈ºywaj bibliotek! W Javie: OWASP Java Encoder. W JS: DOMPurify.</p>
        </div>
    </section>

    <!-- 4. PU≈ÅAPKA REGEX -->
    <section>
        <h2>> RE REGULAR EXPRESSION DOS (ReDoS)</h2>
        <p>≈πle napisane wyra≈ºenie regularne mo≈ºe zawiesiƒá serwer.</p>
        <div class="card">
            <p><strong>Z≈Çy Regex:</strong> <code>(a+)+b</code></p>
            <p>Je≈õli wy≈õlesz ciƒÖg: <code>aaaaaaaaaaaaaaaaaaaaa!</code> (bez 'b' na ko≈Ñcu), silnik Regex wpadnie w "Catastrophic Backtracking", pr√≥bujƒÖc milion√≥w kombinacji. Procesor skoczy do 100%.</p>
            <p><strong>Rada:</strong> Unikaj zagnie≈ºd≈ºonych kwantyfikator√≥w (plus w plusie). U≈ºywaj timeout√≥w dla operacji regex.</p>
        </div>
    </section>

    <!-- CHECKLIST -->
    <section>
        <h2>BLUE TEAM CHECKLIST üõ°Ô∏è</h2>
        <div class="card checklist-card">
            <div class="checklist-item">
                <span class="check-icon">üõ°Ô∏è</span>
                <div><strong>Walidacja po stronie serwera:</strong> Walidacja w JS (na froncie) jest TYLKO dla wygody u≈ºytkownika (UX). Bezpiecze≈Ñstwo zapewnia tylko walidacja na backendzie.</div>
            </div>
            <div class="checklist-item">
                <span class="check-icon">üõ°Ô∏è</span>
                <div><strong>Type Checking:</strong> Czy API sprawdza typy? Je≈õli pole ma byƒá liczbƒÖ (`age: 25`), a dostaje string (`age: "25' OR 1=1"`), powinno rzuciƒá b≈Çƒôdem.</div>
            </div>
            <div class="checklist-item">
                <span class="check-icon">üõ°Ô∏è</span>
                <div><strong>Biblioteki SanityzujƒÖce:</strong> Nie pisz w≈Çasnych funkcji czyszczƒÖcych. U≈ºywaj sprawdzonych (np. DOMPurify dla HTML, OWASP ESAPI).</div>
            </div>
        </div>
    </section>

    <!-- QUIZ -->
    <section id="quiz-section">
        <h2>üéì WERYFIKACJA WIEDZY OBRONNEJ</h2>
        <div id="quiz-container"></div>
    </section>

    <footer>
        <p style="text-align: center; margin-top: 50px; color: #555;">&copy; 2026 Hack & Learn: Web Edition | Modu≈Ç 26</p>
    </footer>
</div>

<!-- DANE DO QUIZU -->
<script>
    const quizData = [
        {
            question: "Jaka jest r√≥≈ºnica miƒôdzy podej≈õciem 'Allowlist' (Bia≈Ça Lista) a 'Blocklist' (Czarna Lista) w walidacji?",
            options: [
                "Blocklist jest bezpieczniejsza.",
                "Allowlist definiuje to, co jest DOZWOLONE (np. tylko litery) i odrzuca resztƒô. Blocklist pr√≥buje zdefiniowaƒá to, co ZABRONIONE (np. s≈Çowo 'script'), co ≈Çatwo obej≈õƒá.",
                "Nie ma r√≥≈ºnicy.",
                "Allowlist dotyczy tylko adres√≥w IP."
            ],
            correct: 1,
            explanation: "Blocklist zawsze przegra z kreatywno≈õciƒÖ hakera (np. `<scr script ipt>`). Allowlist ('Accept Known Good') to jedyne bezpieczne podej≈õcie."
        },
        {
            type: "scenario",
            question: "Deweloper zaimplementowa≈Ç walidacjƒô formularza w JavaScript, aby odciƒÖ≈ºyƒá serwer. Czy to wystarczy?",
            options: [
                "Tak, je≈õli JS jest zminifikowany.",
                "Nie. Walidacja Client-Side s≈Çu≈ºy tylko do poprawy UX (szybka informacja zwrotna). Haker mo≈ºe wy≈ÇƒÖczyƒá JS lub wys≈Çaƒá ≈ºƒÖdanie bezpo≈õrednio do API (np. przez Burp), omijajƒÖc walidacjƒô.",
                "Tak, React to zabezpiecza.",
                "Zale≈ºy od przeglƒÖdarki."
            ],
            correct: 1,
            explanation: "Z≈Çota zasada: Nigdy nie ufaj klientowi. Ka≈ºda regu≈Ça walidacji (d≈Çugo≈õƒá, typ, format) musi byƒá powt√≥rzona na backendzie."
        },
        {
            question: "Co to jest 'Output Encoding' (Escaping) i przed czym chroni?",
            options: [
                "Szyfrowanie bazy danych.",
                "Zamiana znak√≥w specjalnych (np. <, >, \", ') na ich bezpieczne odpowiedniki (np. &lt;), aby przeglƒÖdarka traktowa≈Ça je jako tre≈õƒá, a nie kod. Chroni przed XSS.",
                "Kompresja obrazk√≥w.",
                "Ukrywanie kodu ≈∫r√≥d≈Çowego."
            ],
            correct: 1,
            explanation: "To najskuteczniejsza obrona przed XSS. PrzeglƒÖdarka wy≈õwietli znaczek `<`, ale nie potraktuje go jako poczƒÖtku tagu HTML."
        },
        {
            question: "Co to jest ReDoS (Regular Expression Denial of Service)?",
            options: [
                "Atak na DNS.",
                "Atak wykorzystujƒÖcy ≈∫le skonstruowane wyra≈ºenia regularne (z≈Ço≈ºono≈õƒá wyk≈Çadnicza), kt√≥ry powoduje 100% zu≈ºycia CPU serwera przy przetwarzaniu z≈Ço≈õliwego ciƒÖgu znak√≥w.",
                "Rodzaj wirusa.",
                "Atak na kolory."
            ],
            correct: 1,
            explanation: "Unikaj tzw. 'Evil Regex' (zagnie≈ºd≈ºonych kwantyfikator√≥w). Haker mo≈ºe wys≈Çaƒá kr√≥tki tekst, kt√≥ry 'zawiesi' proces sprawdzania na minuty lub godziny."
        },
        {
            type: "scenario",
            question: "Chcesz pozwoliƒá u≈ºytkownikom na formatowanie tekstu w komentarzach (pogrubienie, kursywa), ale chcesz uniknƒÖƒá XSS. Co jest najlepszym rozwiƒÖzaniem?",
            options: [
                "Pozwoliƒá na czysty HTML i filtrowaƒá s≈Çowo 'script'.",
                "U≈ºyƒá Markdown (i bezpiecznego parsera) lub pozwoliƒá na HTML, ale przepu≈õciƒá go przez sprawdzonƒÖ bibliotekƒô sanityzujƒÖcƒÖ (np. DOMPurify), kt√≥ra usunie niebezpieczne tagi.",
                "Zablokowaƒá wszystkie znaki specjalne.",
                "U≈ºyƒá bazy SQL."
            ],
            correct: 1,
            explanation: "Je≈õli musisz pozwoliƒá na HTML (Rich Text), u≈ºyj 'Sanitization Library'. One parsujƒÖ HTML i budujƒÖ go od nowa, u≈ºywajƒÖc tylko dozwolonych tag√≥w (np. <b>, <i>)."
        },
        {
            question: "Dlaczego walidacja typu danych (Type Checking) w API jest wa≈ºna dla bezpiecze≈Ñstwa?",
            options: [
                "Bo przyspiesza bazƒô danych.",
                "Poniewa≈º zapobiega wielu atakom logicznym i Injection. Je≈õli pole 'ilo≈õƒá' przyjmie tylko Integer, nie da siƒô tam wstrzyknƒÖƒá kodu SQL ani tekstu.",
                "Bo JSON tego wymaga.",
                "To nie jest wa≈ºne."
            ],
            correct: 1,
            explanation: "Silne typowanie to pierwsza linia obrony. Je≈õli API oczekuje liczby, a dostaje string z kodem SQL, powinno od razu rzuciƒá wyjƒÖtkiem, zanim kod dotrze do bazy."
        }
    ];
</script>

<script src="quiz.js"></script>

</body>
</html>