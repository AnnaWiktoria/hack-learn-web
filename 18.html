<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lekcja 18: HTTP Request Smuggling - Hack & Learn</title>
    
    <link rel="stylesheet" href="style.css">

    <style>
        /* Akcent: Split-Brain Magenta (Desynchronization) */
        :root {
            --accent: #ff00cc;
            --accent-glow: rgba(255, 0, 204, 0.3);
        }
        
        .header-cl { color: #00e5ff; font-weight: bold; }
        .header-te { color: #ffd600; font-weight: bold; }
        .smuggled { color: #ff00cc; font-weight: bold; background: rgba(255,0,204,0.1); }
    </style>
</head>
<body>

<div class="container">
    <header>
        <h1>HTTP REQUEST SMUGGLING</h1>
        <p>MODUÅ 18: Desynchronizacja, CL.TE vs TE.CL i PrzejÄ™cie Konta</p>
    </header>

    <!-- 1. MECHANIZM -->
    <section>
        <h2>> PROBLEM DWÃ“CH SZEFÃ“W</h2>
        <p>W nowoczesnym webie rzadko Å‚Ä…czysz siÄ™ bezpoÅ›rednio z serwerem. Twoje Å¼Ä…danie przechodzi przez Å‚aÅ„cuch:</p>
        <div class="card" style="text-align:center; font-family:var(--font-mono);">
            UÅ»YTKOWNIK -> <span style="color:#00e5ff">FRONT-END (Load Balancer)</span> -> <span style="color:#ffd600">BACK-END (Server)</span>
        </div>
        <p>Problem pojawia siÄ™, gdy Frontend i Backend <strong>nie zgadzajÄ… siÄ™</strong> co do tego, gdzie koÅ„czy siÄ™ jedno Å¼Ä…danie, a zaczyna drugie.</p>
    </section>

    <!-- 2. CL vs TE -->
    <section>
        <h2>> DWA SPOSOBY MIERZENIA</h2>
        <p>ProtokÃ³Å‚ HTTP/1.1 ma dwie metody okreÅ›lania dÅ‚ugoÅ›ci wiadomoÅ›ci:</p>
        <div class="card">
            <ul>
                <li><span class="header-cl">Content-Length (CL):</span> Proste. Liczba bajtÃ³w w ciele.</li>
                <li><span class="header-te">Transfer-Encoding: chunked (TE):</span> Dane wysyÅ‚ane w kawaÅ‚kach. Koniec oznacza kawaÅ‚ek o rozmiarze <code>0</code>.</li>
            </ul>
            <p><strong>ATAK:</strong> Co jeÅ›li wyÅ›lemy OBA nagÅ‚Ã³wki naraz, ale jeden serwer zignoruje CL, a drugi zignoruje TE? Dochodzi do <strong>desynchronizacji</strong>.</p>
        </div>
    </section>

    <!-- 3. TYPY ATAKÃ“W -->
    <section>
        <h2>> SCENARIUSZE CL.TE i TE.CL</h2>

        <div class="card">
            <h3>1. CL.TE (Front patrzy na CL, Back patrzy na TE)</h3>
            <p>Frontend widzi Content-Length i myÅ›li, Å¼e to jedno duÅ¼e Å¼Ä…danie. PrzesyÅ‚a je do Backendu. Backend widzi <code>chunked</code> i czyta tylko do pierwszego <code>0</code>.</p>
            <pre><code>POST / HTTP/1.1
Host: target.com
<span class="header-cl">Content-Length: 13</span>
<span class="header-te">Transfer-Encoding: chunked</span>

0

<span class="smuggled">SMUGGLED</span></code></pre>
            <p>Backend koÅ„czy czytanie na <code>0</code>. SÅ‚owo <span class="smuggled">SMUGGLED</span> zostaje w buforze jako poczÄ…tek <strong>KOLEJNEGO</strong> Å¼Ä…dania (ktÃ³re moÅ¼e naleÅ¼eÄ‡ do innego uÅ¼ytkownika!).</p>
        </div>

        <div class="card">
            <h3>2. TE.CL (Odwrotnie)</h3>
            <p>Frontend czyta kawaÅ‚ki (TE), a Backend patrzy na dÅ‚ugoÅ›Ä‡ (CL). To pozwala "przemyciÄ‡" zÅ‚oÅ›liwe Å¼Ä…danie wewnÄ…trz kawaÅ‚ka chunked.</p>
        </div>
    </section>

    <!-- 4. SKUTKI (IMPACT) -->
    <section>
        <h2>> CO MOÅ»NA ZROBIÄ†?</h2>
        <p>To nie jest tylko bÅ‚Ä…d teoretyczny. Skutki sÄ… krytyczne.</p>

        <div class="card">
            <h3>BYPASS ZABEZPIECZEÅƒ</h3>
            <p>Frontend blokuje dostÄ™p do <code>/admin</code>. Przemycasz Å¼Ä…danie do <code>/admin</code> wewnÄ…trz legalnego Å¼Ä…dania. Frontend przepuszcza (bo widzi tylko to pierwsze), a Backend wykonuje to ukryte.</p>
        </div>

        <div class="card" style="border-color: var(--danger);">
            <h3>KRADZIEÅ» SESJI (POISONING)</h3>
            <p>Przemycasz Å¼Ä…danie, ktÃ³re "czeka" w buforze Backendu. Gdy <strong>inny uÅ¼ytkownik</strong> wyÅ›le swoje Å¼Ä…danie, zostanie ono doklejone do Twojego.</p>
            <p>JeÅ›li Twoje przemycone Å¼Ä…danie to wysÅ‚anie komentarza, Å¼Ä…danie ofiary (z jej ciasteczkami!) wylÄ…duje w treÅ›ci Twojego komentarza.</p>
        </div>
    </section>

    <!-- CHECKLIST -->
    <section>
        <h2>CHECKLISTA / RED FLAGS</h2>
        <div class="card checklist-card">
            <div class="checklist-item">
                <span class="check-icon">âš </span>
                <div><strong>HTTP/1.1 na Load Balancerach:</strong> Smuggling dotyczy gÅ‚Ã³wnie HTTP/1.1. HTTP/2 jest znacznie bezpieczniejsze (choÄ‡ konwersja H2->H1 teÅ¼ bywa dziurawa).</div>
            </div>
            <div class="checklist-item">
                <span class="check-icon">âš </span>
                <div><strong>Obfuscation TE:</strong> NagÅ‚Ã³wki typu `Transfer-Encoding: xchunked` lub zduplikowane `Transfer-Encoding`. SÅ‚uÅ¼Ä… do oszukania jednego z serwerÃ³w.</div>
            </div>
            <div class="checklist-item">
                <span class="check-icon">âš </span>
                <div><strong>Burp Scanner:</strong> To bÅ‚Ä…d bardzo trudny do wykrycia rÄ™cznie (wymaga precyzji co do bajta). UÅ¼ywaj wtyczki "HTTP Request Smuggler".</div>
            </div>
        </div>
    </section>

    <!-- QUIZ -->
    <section id="quiz-section">
        <h2>ğŸ“ WERYFIKACJA WIEDZY</h2>
        <div id="quiz-container"></div>
    </section>

    <footer>
        <p style="text-align: center; margin-top: 50px; color: #555;">&copy; 2026 Hack & Learn: Web Edition | ModuÅ‚ 18</p>
    </footer>
</div>

<!-- DANE DO QUIZU -->
<script>
    const quizData = [
        {
            question: "Na czym polega istota ataku HTTP Request Smuggling?",
            options: [
                "Na przemycaniu narkotykÃ³w przez HTTP.",
                "Na desynchronizacji miÄ™dzy serwerem Frontendowym a Backendowym w kwestii tego, gdzie koÅ„czy siÄ™ jedno Å¼Ä…danie, a zaczyna drugie.",
                "Na szyfrowaniu Å¼Ä…daÅ„ HTTP.",
                "Na wysyÅ‚aniu zbyt duÅ¼ych plikÃ³w."
            ],
            correct: 1,
            explanation: "To bÅ‚Ä…d interpretacji dÅ‚ugoÅ›ci wiadomoÅ›ci. Jeden serwer myÅ›li, Å¼e wiadomoÅ›Ä‡ siÄ™ skoÅ„czyÅ‚a, a drugi, Å¼e jeszcze trwa (lub odwrotnie)."
        },
        {
            question: "Jakie dwa nagÅ‚Ã³wki HTTP sÄ… kluczowe w tym ataku?",
            options: [
                "Content-Type i Accept",
                "Content-Length (CL) i Transfer-Encoding (TE)",
                "Host i Origin",
                "Cookie i Set-Cookie"
            ],
            correct: 1,
            explanation: "CL okreÅ›la dÅ‚ugoÅ›Ä‡ w bajtach. TE (chunked) okreÅ›la koniec za pomocÄ… bloku o rozmiarze 0. Konflikt miÄ™dzy nimi to ÅºrÃ³dÅ‚o problemu."
        },
        {
            question: "Co oznacza skrÃ³t CL.TE?",
            options: [
                "Frontend uÅ¼ywa Content-Length, Backend uÅ¼ywa Transfer-Encoding.",
                "Frontend uÅ¼ywa Transfer-Encoding, Backend uÅ¼ywa Content-Length.",
                "Oba serwery uÅ¼ywajÄ… Content-Length.",
                "Clear Text . Text Encoding"
            ],
            correct: 0,
            explanation: "Pierwszy czÅ‚on (CL) odnosi siÄ™ do serwera, ktÃ³ry pierwszy przetwarza Å¼Ä…danie (Frontend), drugi (TE) do Backendu."
        },
        {
            question: "Jaki znak/wartoÅ›Ä‡ oznacza koniec wiadomoÅ›ci w kodowaniu `Transfer-Encoding: chunked`?",
            options: [
                "Znak koÅ„ca pliku (EOF).",
                "Blok o rozmiarze 0 (zero chunk), zakoÅ„czony pustÄ… liniÄ….",
                "SÅ‚owo 'END'.",
                "ZamkniÄ™cie poÅ‚Ä…czenia TCP."
            ],
            correct: 1,
            explanation: "Serwer czytajÄ…cy 'chunked' pobiera dane kawaÅ‚ek po kawaÅ‚ku, aÅ¼ napotka `0\r\n\r\n`."
        },
        {
            type: "scenario",
            question: "UdaÅ‚o Ci siÄ™ 'przemyciÄ‡' Å¼Ä…danie POST, ktÃ³re zapisuje komentarz. Czeka ono w buforze Backendu. Nagle inny uÅ¼ytkownik wchodzi na stronÄ™. Co siÄ™ stanie?",
            options: [
                "Serwer siÄ™ zawiesi.",
                "Å»Ä…danie uÅ¼ytkownika zostanie 'doklejone' do Twojego przemyconego Å¼Ä…dania. Jego sesja i dane mogÄ… wylÄ…dowaÄ‡ w treÅ›ci Twojego komentarza.",
                "UÅ¼ytkownik dostanie bÅ‚Ä…d 404.",
                "Nic, ataki dziaÅ‚ajÄ… tylko na Ciebie."
            ],
            correct: 1,
            explanation: "To najgroÅºniejszy skutek. MoÅ¼esz kraÅ›Ä‡ sesje, hasÅ‚a i dane innych uÅ¼ytkownikÃ³w, nie majÄ…c z nimi Å¼adnego kontaktu (tzw. Request Hijacking)."
        },
        {
            question: "Dlaczego HTTP/2 jest generalnie odporne na Request Smuggling (w swojej czystej postaci)?",
            options: [
                "Bo jest szybsze.",
                "Bo uÅ¼ywa mechanizmu ramek binarnych z wbudowanÄ… dÅ‚ugoÅ›ciÄ… dla kaÅ¼dej ramki, eliminujÄ…c niejednoznacznoÅ›Ä‡ CL vs TE.",
                "Bo nie uÅ¼ywa TCP.",
                "Bo Google tak powiedziaÅ‚."
            ],
            correct: 1,
            explanation: "W HTTP/2 dÅ‚ugoÅ›Ä‡ jest jednoznaczna. Ryzyko pojawia siÄ™ jednak przy tzw. 'HTTP/2 Downgrade', gdy Frontend zamienia H2 na H1.1 dla Backendu."
        },
        {
            question: "Co to jest atak TE.TE?",
            options: [
                "Oba serwery uÅ¼ywajÄ… TE, ale jeden z nich udaje siÄ™ oszukaÄ‡ poprzez obfuskacjÄ™ nagÅ‚Ã³wka (np. `Transfer-Encoding: xchunked`), aby przeszedÅ‚ na CL.",
                "Atak na telefony.",
                "Double Transfer Encoding.",
                "BÅ‚Ä…d 500."
            ],
            correct: 0,
            explanation: "Hakerzy prÃ³bujÄ… zmyliÄ‡ parsery, wysyÅ‚ajÄ…c np. dwa nagÅ‚Ã³wki TE lub znieksztaÅ‚cone nazwy, liczÄ…c, Å¼e jeden serwer je zignoruje (fallback do CL)."
        },
        {
            type: "scenario",
            question: "Frontend blokuje dostÄ™p do URL `/admin`. Jak Smuggling moÅ¼e pomÃ³c w obejÅ›ciu tego zabezpieczenia?",
            options: [
                "Nie moÅ¼e.",
                "WysyÅ‚asz legalne Å¼Ä…danie do `/home` (ktÃ³re Frontend widzi i puszcza), ale w jego ciele przemycasz drugie Å¼Ä…danie do `/admin` (ktÃ³re Backend wykona).",
                "ZgadujÄ…c hasÅ‚o admina.",
                "WyÅ‚Ä…czajÄ…c Frontend."
            ],
            correct: 1,
            explanation: "Frontend sprawdza tylko 'zewnÄ™trzne' Å¼Ä…danie. Backend wykonuje to, co otrzymaÅ‚, w tym to 'ukryte' w Å›rodku."
        },
        {
            question: "Jakie narzÄ™dzie w Burp Suite automatyzuje wykrywanie tego bÅ‚Ä™du?",
            options: [
                "SQLmap.",
                "HTTP Request Smuggler (rozszerzenie BApp Store).",
                "Dirbuster.",
                "Decoder."
            ],
            correct: 1,
            explanation: "RÄ™czne liczenie bajtÃ³w w Smugglingu jest koszmarem. To narzÄ™dzie od Jamesa Kettle'a robi to automatycznie i wykrywa desynchronizacjÄ™."
        },
        {
            question: "Jaka jest najlepsza obrona przed Request Smuggling?",
            options: [
                "UÅ¼ywanie tylko jednego serwera (brak podziaÅ‚u Front/Back).",
                "Wymuszenie HTTP/2 na caÅ‚ej Å›cieÅ¼ce (End-to-End) lub Å›cisÅ‚a konfiguracja parserÃ³w HTTP, by odrzucaÅ‚y niejednoznaczne Å¼Ä…dania.",
                "Blokowanie metody POST.",
                "UÅ¼ywanie HTTPS."
            ],
            correct: 1,
            explanation: "JeÅ›li caÅ‚a komunikacja odbywa siÄ™ po HTTP/2, problem znika. AlternatywÄ… jest konfiguracja serwerÃ³w tak, by bÅ‚Ä…d parsowania zamykaÅ‚ poÅ‚Ä…czenie."
        }
    ];
</script>

<script src="quiz.js"></script>

</body>
</html>